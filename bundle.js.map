{"version":3,"sources":["webpack:///webpack/bootstrap 11fd715d425dc43eca64","webpack:///./src/index.js","webpack:///./src/tags.js","webpack:///./src/todo-store.js","webpack:///./src/dispatcher.js","webpack:///./~/riot/riot.js"],"names":[],"mappings":"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CL,IAAG;AACH;;AAEA;;AAEA;AACA;AACA,mBAAkB;AAClB,+CAA8C;AAC9C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAe,uBAAuB;;AAEtC;AACA;AACA;AACA,6BAA4B,yBAAyB;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,iCAAiC;;AAE5D;AACA;AACA;AACA;;AAEA,MAAK;;AAEL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAgB,uDAAuD;AACvE;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB;AACpB;;AAEA;AACA;;AAEA,kCAAiC,yBAAyB;;AAE1D;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,cAAc;;AAEnC;AACA;AACA;;AAEA,EAAC","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 11fd715d425dc43eca64\n **/","/*\n Simple Todo app. Port of React/Flux Todo app https://github.com/srackham/flux-backbone-todo\n */\n'use strict';\n\nimport riot from 'riot';\nimport TodoStore from './todo-store.js';\nimport dispatcher from './dispatcher.js';\nimport './tags.js'\n\nlet todoStore = new TodoStore(dispatcher);\ndispatcher.addStore(todoStore);\nriot.mount('todo-app', {store: todoStore});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import riot from 'riot';\n\nriot.tag('todo-app',\n\n  `<h3>Todos</h3>\n   <todo-form store=\"{opts.store}\"></todo-form>\n   <todo-list store=\"{opts.store}\"></todo-list>\n   <p>\n     Want a second fully synchronized list? Just declare another list component:\n     no code required, no events to wire up!\n   </p>\n   <todo-list store=\"{opts.store}\"></todo-list>`,\n\n  function(opts) {\n    let dispatcher = this.opts.store.dispatcher;\n    this.on('mount', () => dispatcher.trigger(dispatcher.INIT_TODOS));\n  }\n\n);\n\n\nriot.tag('todo-form',\n\n  `<form onsubmit=\"{add}\">\n     <input name=\"input\" type=\"text\" placeholder=\"New Todo\" autofocus=\"true\">\n     <input type=\"submit\" value=\"Add Todo\">\n   </form>\n   <button onclick=\"{clear}\">Clear Completed</button>`,\n\n  function(opts) {\n    let store = this.opts.store;\n    let dispatcher = store.dispatcher;\n\n    this.add = (e) => {\n      if (this.input.value) {\n        dispatcher.trigger(dispatcher.ADD_TODO, {title: this.input.value, done: false});\n        this.input.value = ''\n      }\n    };\n\n    this.clear = (e) => {\n      dispatcher.trigger(dispatcher.CLEAR_TODOS);\n    };\n  }\n\n);\n\n\nriot.tag('todo-list',\n\n  `<ul>\n     <li each=\"{todo in opts.store.todos}\">\n       <todo-item store=\"{parent.opts.store}\" todo=\"{todo}\">\n     </li>\n   </ul>`,\n\n  function(opts) {\n    let store = this.opts.store;\n    store.on(store.CHANGED_EVENT, () => this.update());\n  }\n\n);\n\n\nriot.tag('todo-item',\n\n  `<span class=\"{done: opts.todo.done}\" onclick=\"{toggle}\">\n     {opts.todo.title}\n   </span>`,\n\n  function(opts) {\n    let dispatcher = this.opts.store.dispatcher;\n\n    this.toggle = () => {\n      dispatcher.trigger(dispatcher.TOGGLE_TODO, opts.todo);\n    }\n  }\n\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tags.js\n **/","// TodoStore definition.\n// Flux stores house application logic and state that relate to a specific domain.\n// The store responds to relevant events emitted by the flux dispatcher.\n// The store emits change events to any listening views, so that they may react\n// and redraw themselves.\n'use strict';\n\nimport Riot from 'riot';\n\nexport default function TodoStore(dispatcher) {\n  const LOCALSTORAGE_KEY = 'riot-todo';\n  Riot.observable(this); // Riot provides our event emitter.\n  this.CHANGED_EVENT = 'CHANGED_EVENT';\n  let json = window.localStorage.getItem(LOCALSTORAGE_KEY);\n  this.todos = (json && JSON.parse(json)) || [];\n  this.dispatcher = dispatcher;\n\n  let triggerChanged = () => {\n    // Brute force update all.\n    window.localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(this.todos));\n    this.trigger(this.CHANGED_EVENT);\n  };\n\n  // Event handlers.\n  this.on(dispatcher.ADD_TODO, (todo) => {\n    this.todos.push(todo);\n    triggerChanged();\n  });\n\n  this.on(dispatcher.TOGGLE_TODO, (todo) => {\n    todo.done = !todo.done;\n    triggerChanged();\n  });\n\n  this.on(dispatcher.CLEAR_TODOS, () => {\n    this.todos = this.todos.filter(todoItem => !todoItem.done);\n    triggerChanged();\n  });\n\n  this.on(dispatcher.INIT_TODOS, () => {\n    triggerChanged();\n  });\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo-store.js\n **/","// RiotControl dispatcher with Todo actions and formatted as node commonjs module.\n// https://github.com/jimsparkman/RiotControl\n\nmodule.exports = {\n\n  // Dispatcher actions.\n  ADD_TODO: 'ADD_TODO',\n  TOGGLE_TODO: 'TOGGLE_TODO',\n  CLEAR_TODOS: 'CLEAR_TODOS',\n  INIT_TODOS: 'INIT_TODOS',\n\n  _stores: [],\n\n  addStore(store) {\n    this._stores.push(store)\n  },\n\n  trigger() {\n    let args = [].slice.call(arguments);\n    console.log('dispatcher: trigger: ' + args);\n    this._stores.forEach(function(el) {\n      el.trigger.apply(null, args)\n    })\n  },\n\n  on(ev, cb) {\n    this._stores.forEach(function(el) {\n      el.on(ev, cb)\n    })\n  },\n\n  off(ev, cb) {\n    this._stores.forEach(function(el) {\n      if (cb)\n        el.off(ev, cb);\n      else\n        el.off(ev)\n    })\n  },\n\n  one(ev, cb) {\n    this._stores.forEach(function(el) {\n      el.one(ev, cb)\n    })\n  }\n\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/dispatcher.js\n **/","/* Riot v2.0.8, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function() {\n\nvar riot = { version: 'v2.0.8', settings: {} }\n\n'use strict'\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {}\n\n  el.on = function(events, fn) {\n    if (typeof fn == 'function') {\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else if (fn) {\n      var arr = callbacks[events]\n      for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n        if (cb == fn) { arr.splice(i, 1); i-- }\n      }\n    } else {\n      events.replace(/\\S+/g, function(name) {\n        callbacks[name] = []\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    if (fn) fn.one = 1\n    return el.on(name, fn)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fn.one) { fns.splice(i, 1); i-- }\n         else if (fns[i] !== fn) { i-- } // Makes self-removal possible during iteration\n        fn.busy = 0\n      }\n    }\n\n    return el\n  }\n\n  return el\n\n}\n;(function(riot, evt) {\n\n  // browsers only\n  if (!this.top) return\n\n  var loc = location,\n      fns = riot.observable(),\n      current = hash(),\n      win = window\n\n  function hash() {\n    return loc.hash.slice(1)\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n\n})(riot, 'hashchange')\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n\n// Customizable brackets\n\n  riot.settings.brackets = '[ ]'\n  riot.settings.brackets = '<% %>'\n\n*/\n\nvar tmpl = (function() {\n\n  var cache = {},\n      brackets,\n      re_expr,\n      re_vars = /(\"|').+?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_]\\w*)/gi\n              // [ 1            ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings: \"a b\", 'a b', 'a \\'b\\''\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  return function(str, data) {\n\n    // make sure we use current brackets setting\n    var b = riot.settings.brackets || '{ }'\n    if(b != brackets){\n      brackets = b.split(' ')\n      re_expr = re(/({[\\s\\S]*?})/)\n    }\n\n    // build a template (or get it from cache), render with data\n    // (or just test if string has expression when called w/o data)\n    return data\n      ? str && (cache[str] = cache[str] || tmpl(str))(data)\n      : re_expr.test(str)\n\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    p = (s || brackets.join(''))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(re(/\\\\{/), '\\uFFF0')\n      .replace(re(/\\\\}/), '\\uFFF1')\n      \n      // split string to expression and non-expresion parts\n      .split(re_expr)\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n            return i % 2\n\n              // evaluate the expressions\n              ? expr(s, 1)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n          }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets[0])\n      .replace(/\\uFFF1/g, brackets[1])\n\n    )\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, curly brackets, strip comments\n      .replace(re(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w-\"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' + s.replace(/\\W*([\\w-]+)\\W*:([^,]+)/g, function(_, k, v) {\n\n          // safely execute vars to prevent undefined value errors\n          return v.replace(/\\w[^,|& ]*/g, function(v) { return wrap(v, n) }) + '?\"' + k + '\":\"\",'\n\n        }) + '].join(\" \")'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    return '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(re_vars, function(s, _, v) { return v ? '(d.'+v+'===undefined?window.'+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // change regexp to use custom brackets\n\n  function re(r) {\n    return RegExp(r.source\n                   .split('{').join('\\\\'+brackets[0])\n                   .split('}').join('\\\\'+brackets[1]),\n                  r.global ? 'g' : '')\n  }\n\n})()\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var ret = { val: expr },\n      els = expr.split(/\\s+in\\s+/)\n\n  if (els[1]) {\n    ret.val = '{ ' + els[1]\n    els = els[0].slice(1).trim().split(/,\\s*/)\n    ret.key = els[0]\n    ret.pos = els[1]\n  }\n  return ret\n}\n\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var template = dom.outerHTML,\n      prev = dom.previousSibling,\n      root = dom.parentNode,\n      rendered = [],\n      tags = [],\n      checksum\n\n  expr = loopKeys(expr)\n\n  // clean template code after update (and let walk finish it's parse)\n  parent.one('update', function() {\n    root.removeChild(dom)\n\n  }).one('mount', function() {\n    if (!hasParent(root)) root = parent.root\n\n  }).on('update', function() {\n\n    var items = tmpl(expr.val, parent)\n    if (!items) return\n\n    // object loop. any changes cause full redraw\n    if (!Array.isArray(items)) {\n      var testsum = JSON.stringify(items)\n      if (testsum == checksum) return\n      checksum = testsum\n\n      // clear old items\n      tags.map(function(tag) {\n        tag.unmount()\n      })\n\n      tags = rendered = []\n\n      items = Object.keys(items).map(function(key, i) {\n        var obj = {}\n        obj[expr.key] = key\n        obj[expr.pos] = items[key]\n        return obj\n      })\n\n    }\n\n    // unmount redundant\n    arrDiff(rendered, items).map(function(item) {\n      var pos = rendered.indexOf(item),\n          tag = tags[pos]\n\n      if (tag) {\n        tag.unmount()\n        rendered.splice(pos, 1)\n        tags.splice(pos, 1)\n      }\n    })\n\n    // mount new\n    var nodes = root.childNodes,\n        prev_index = Array.prototype.indexOf.call(nodes, prev)\n\n    arrDiff(items, rendered).map(function(item, i) {\n\n      var pos = items.indexOf(item)\n\n      if (!checksum && expr.key) {\n        var obj = {}\n        obj[expr.key] = item\n        obj[expr.pos] = pos\n        item = obj\n      }\n\n      var tag = new Tag({ tmpl: template }, {\n        before: nodes[prev_index + 1 + pos],\n        parent: parent,\n        root: root,\n        loop: true,\n        item: item\n      })\n\n      tags.splice(pos, 0, tag)\n\n    })\n\n    rendered = items.slice()\n\n  })\n\n}\nfunction parseNamedElements(root, tag, expressions) {\n  walk(root, function(dom) {\n    if (dom.nodeType != 1) return\n\n    each(dom.attributes, function(attr) {\n      if (/^(name|id)$/.test(attr.name)) tag[attr.value] = dom\n    })\n  })\n}\n\nfunction parseLayout(root, tag, expressions) {\n\n  function addExpr(dom, value, data) {\n    if (tmpl(value) || data) {\n      var expr = { dom: dom, expr: value }\n      expressions.push(extend(expr, data || {}))\n    }\n  }\n\n  walk(root, function(dom) {\n\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // child tag\n    var impl = tag_impl[dom.tagName.toLowerCase()]\n    if (impl) {\n      impl = new Tag(impl, { root: dom, parent: tag })\n      return false\n    }\n\n    // attributes\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n          value = attr.value\n\n      // expressions\n      var bool = name.split('__')[1]\n      addExpr(dom, value, { attr: bool || name, bool: bool })\n\n      if (bool) {\n        remAttr(dom, name)\n        return false\n      }\n\n    })\n\n  })\n\n}\nfunction Tag(impl, conf) {\n\n  var self = riot.observable(this),\n      expressions = [],\n      attributes = {},\n      parent = conf.parent,\n      is_loop = conf.loop,\n      root = conf.root,\n      opts = conf.opts,\n      item = conf.item\n\n  // cannot initialize twice on the same root element\n  if (!is_loop && root.riot) return\n  root.riot = 1\n\n  opts = opts || {}\n\n  extend(this, { parent: parent, root: root, opts: opts, children: [] })\n  extend(this, item)\n\n\n  // attributes\n  each(root.attributes, function(attr) {\n    var name = attr.name,\n        val = attr.value\n\n    attributes[name] = val\n\n    // remove dynamic attributes from node\n    if (val.indexOf('{') >= 0) {\n      remAttr(root, name)\n      return false\n    }\n  })\n\n  // options\n  function updateOpts() {\n    Object.keys(attributes).map(function(name) {\n      opts[name] = tmpl(attributes[name], parent || self)\n    })\n  }\n\n  updateOpts()\n\n  // child\n  parent && parent.children.push(this)\n\n  var dom = mkdom(impl.tmpl),\n      loop_dom\n\n  // named elements\n  parseNamedElements(dom, this)\n\n  this.update = function(data, init) {\n    extend(self, data)\n    extend(self, item)\n    self.trigger('update')\n    updateOpts()\n    update(expressions, self, item)\n    self.trigger('updated')\n  }\n\n  this.unmount = function() {\n\n    if (is_loop) {\n      root.removeChild(loop_dom)\n\n    } else {\n      var p = root.parentNode\n      p && p.removeChild(root)\n    }\n\n    // splice from parent.children[]\n    if (parent) {\n      var els = parent.children\n      els.splice(els.indexOf(self), 1)\n    }\n\n    self.trigger('unmount')\n\n    // cleanup\n    parent && parent.off('update', self.update)\n    mounted = false\n  }\n\n  function mount() {\n    while (dom.firstChild) {\n      if (is_loop) {\n        loop_dom = dom.firstChild\n        root.insertBefore(dom.firstChild, conf.before || null) // null needed for IE8\n\n      } else {\n        root.appendChild(dom.firstChild)\n      }\n    }\n\n    if (!hasParent(root)) self.root = root = parent.root\n\n    self.trigger('mount')\n\n    // one way data flow: propagate updates and unmounts downwards from parent to children\n    parent && parent.on('update', self.update).one('unmount', self.unmount)\n\n  }\n\n  // initialize\n  if (impl.fn) impl.fn.call(this, opts)\n\n  // layout\n  parseLayout(dom, this, expressions)\n\n  this.update()\n  mount()\n\n}\n\n\nfunction setEventHandler(name, handler, dom, tag, item) {\n\n  dom[name] = function(e) {\n\n    // cross browser event fix\n    e = e || window.event\n    e.which = e.which || e.charCode || e.keyCode\n    e.target = e.target || e.srcElement\n    e.currentTarget = dom\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    tag.update()\n  }\n\n}\n\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n// item = currently looped item\nfunction update(expressions, tag, item) {\n\n  each(expressions, function(expr) {\n    var dom = expr.dom,\n        attr_name = expr.attr,\n        value = tmpl(expr.expr, tag)\n\n    if (value == null) value = ''\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attr_name) return dom.nodeValue = value\n\n    // remove attribute\n    if (!value && expr.bool || /obj|func/.test(typeof value)) remAttr(dom, attr_name)\n\n    // event handler\n    if (typeof value == 'function') {\n      setEventHandler(attr_name, value, dom, tag, item)\n\n    // if- conditional\n    } else if (attr_name == 'if') {\n\n      remAttr(dom, attr_name)\n\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        stub && insertTo(stub.parentNode, stub, dom)\n\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n      }\n\n    // show / hide\n    } else if (/^(show|hide)$/.test(attr_name)) {\n      remAttr(dom, attr_name)\n      if (attr_name == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // normal attribute\n    } else {\n      if (expr.bool) {\n        dom[attr_name] = value\n        if (!value) return\n        value = attr_name\n      }\n\n      dom.setAttribute(attr_name, value)\n    }\n\n  })\n\n}\nfunction each(nodes, fn) {\n  for (var i = 0; i < (nodes || []).length; i++) {\n    if (fn(nodes[i], i) === false) i--\n  }\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction extend(obj, from) {\n  from && Object.keys(from).map(function(key) {\n    obj[key] = from[key]\n  })\n  return obj\n}\n\nfunction mkdom(template) {\n  var tag_name = template.trim().slice(1, 3).toLowerCase(),\n      root_tag = /td|th/.test(tag_name) ? 'tr' : tag_name == 'tr' ? 'tbody' : 'div'\n      el = document.createElement(root_tag)\n\n  el.stub = true\n  el.innerHTML = template\n  return el\n}\n\nfunction walk(dom, fn) {\n  dom = fn(dom) === false ? dom.nextSibling : dom.firstChild\n\n  while (dom) {\n    walk(dom, fn)\n    dom = dom.nextSibling\n  }\n}\n\nfunction arrDiff(arr1, arr2) {\n  return arr1.filter(function(el) {\n    return arr2.indexOf(el) < 0\n  })\n}\n\n// HTMLDocument == IE8 thing\nfunction hasParent(el) {\n  var p = el.parentNode,\n      doc = window.HTMLDocument\n\n  return p && !(doc && p instanceof doc)\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Each tag stores an array of child tags.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtual_dom = [],\n    tag_impl = {}\n\nriot.tag = function(name, html, fn) {\n  tag_impl[name] = { name: name, tmpl: html, fn: fn }\n}\n\nvar mountTo = riot.mountTo = function(root, tagName, opts) {\n  var impl = tag_impl[tagName], tag\n\n  if (impl) tag = new Tag(impl, { root: root, opts: opts })\n\n  if (tag) {\n    virtual_dom.push(tag)\n    return tag.on('unmount', function() {\n      virtual_dom.splice(virtual_dom.indexOf(tag), 1)\n    })\n  }\n}\n\nriot.mount = function(selector, opts) {\n  if (selector == '*') selector = Object.keys(tag_impl).join(', ')\n\n  var tags = []\n\n  each(document.querySelectorAll(selector), function(root) {\n\n    var tagName = root.tagName.toLowerCase(),\n        tag = mountTo(root, tagName, opts)\n\n    if (tag) tags.push(tag)\n  })\n\n  return tags\n}\n\n// update everything\nriot.update = function() {\n  virtual_dom.map(function(tag) {\n    tag.update()\n  })\n  return virtual_dom\n}\n\n\n// support CommonJS\nif (typeof exports === 'object')\n  module.exports = riot\n\n// support AMD\nelse if (typeof define === 'function' && define.amd)\n  define(function() { return riot })\n\n// support browser\nelse\n  this.riot = riot\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"bundle.js"}